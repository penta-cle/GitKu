java内存泄漏：是指程序中已动态分配的堆内存，因为某种原因程序未释放或无法释放，造成系统内存的浪费，导致系统运行速度减慢或系统崩溃等严重后果

### 1、面向对象的三大特性：

继承：java允许一个类继承另一个类的方法及字段
封装：隐藏内部实现的细节，只对外提供调用方法的接口
多态：父类引用指向子类对象。方法重写和重载其实也属于多态的体现。

### 2、抽象类和接口有什么区别？

抽象类包含抽象方法，但是该类的方法不一定都是抽象方法。而接口里的方法都是抽象方法。抽象类和接口被继承/实现后，子类或者实现该接口的类都要重写它们的抽象方法。但是一个类只能继承一个抽象类，而接口可以被多个类实现。

* 抽象类可以被继承只能有一个，更关注与事物的本质是什么 is a，定义抽象类的代价较高 ；
* 接口可以被继承多个，更关注于如何去操作事物 like a 定义接口会使设计阶段降低难度；

### 3、接口可以被继承吗？

java类只能实现接口，但是接口可以继承接口。

### 4、java存在内存泄漏吗？

从理论上来说，因为存在垃圾回收机制，所以Java不存在内存泄露。但在实际开发情况中，有一些可达但是未被使用的对象，所以还是存在内存泄露的。

### 5、hashcode 与 equals

hashcode的作用是为了获取哈希码，通过获取的哈希码来去判断对象在hash表中的位置，为什么会需要hashcode？hashset如何检查重复：当对象加入到hashset中后，hashset会获取该对象的hash值，来去判断当前对象的位置，如果没有值，就会视为该对象没有重复，随机分配到其他位置，如果有值就会调用equals方法，来判断两个对象是否相同，相同则hashset不会让其操作成功；

### 6、ArrayList 和 LinkedList 的区别

* ArrayList 基于动态数组，随机访问更为有利，但是如果基于他的扩容机制中的数组大小是预先固定的，如果大小不够 进行添加操作时 需要new 一个新的ArrayList数组，同时插入数据还会涉及到元素的移动 比较消耗性能；
* LinkedList 基于链表结构 更适合做数据的插入和删除，数组大小不固定但是不适合做查询操作，每当进行查询操作时就会遍历一次数组，并且查询时不能使用 for 循环、只能使用 iterator 迭代器，因为每次 for循环时通过 get(i)时就会遍历一次数组 性能消耗大

### 7、hashMap 和 hashTable 的区别

* hashMap 线程不安全、但是效率比较高，底层数据结构【数组 + 链表的形式】 在jdk1.8之后新增了在解决hash冲突时，如果链表长度大于8时会自动转化为红黑树，以减少搜索时间，hashtable没有这样的机制；
* hashTable 线程因为内部方法都是经过synchronized 修饰

### 8、如何实现一个IOC容器

* 配置文件配置包扫描路径
* 扫描包获取 .class 文件 
* 反射，确定需要交给 IOC 管理的类
* 对需要注入的类进行依赖注入

### 9、字节码

java程序面向虚拟机，生成虚拟机能够理解的代码，随后通过解释器将虚拟机代码转换为特定系统的机器码执行，这种供虚拟机理解的代码叫做字节码

### 10、串行、并行、并发

* 串行在时间上没有重叠，前一个任务没有结束，后一个任务只能等待；
* 并行任务在时间上重叠两个任务同一时间运行 互不干扰；
* 并发彼此干扰，两个任务 统一时间，只有一个任务，交替运行

### 11、线程的生命周期

创建、就绪、运行、阻塞、死亡

**阻塞：**

1. 等待阻塞：执行 wait() 方法线程释放所有占用的资源，JVM会把该线程放入 “等待池” 中，只有调用notify notifyall才能唤醒 
2. 同步阻塞
3. 其他阻塞

保证**线程安全：**

* 原子性：提供互斥访问，同一时刻只能有一个线程对数据操作
* 可见性：一个线程对主内存的修改可以及时的被其他线程看到
* 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序

### 12、乐观锁、悲观锁

* **悲观锁：**查询完事务时就将线程锁起来，知道提交完成；
* **乐观锁：**修改事务时就将线程锁起来，通过version进行控制锁定

### 13、IOC容器的理解

* **容器概念：**实际上就是一个 map （key—value），里面存的是各种对象（在xml中配置的各种 bean 节点、@repository、@service、@controller等），项目启动时会读取配置文件中的bean节点
* **控制反转：**可以理解为一个核心控制器，需要的对象A、B全都放到IOC容器中之后，对象A不需要手动引入需要的对象B，IOC容器会主动创建所需要的对象B然后送到对象A的地方，由原本的主动引入变成了被动，所以叫做控制反转
* 依赖注入

### 14、SpringBean 的生命周期

* 实例化 instantiation
* 属性赋值 populate
* 初始化 Initialization
* 销毁 Destruction